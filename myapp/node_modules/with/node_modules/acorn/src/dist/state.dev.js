"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Parser = exports.plugins = void 0;

var _identifier = require("./identifier");

var _tokentype = require("./tokentype");

var _whitespace = require("./whitespace");

var _options = require("./options");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var plugins = {};
exports.plugins = plugins;

function keywordRegexp(words) {
  return new RegExp("^(" + words.replace(/ /g, "|") + ")$");
}

var Parser =
/*#__PURE__*/
function () {
  function Parser(options, input, startPos) {
    _classCallCheck(this, Parser);

    this.options = options = (0, _options.getOptions)(options);
    this.sourceFile = options.sourceFile;
    this.keywords = keywordRegexp(_identifier.keywords[options.ecmaVersion >= 6 ? 6 : 5]);
    var reserved = options.allowReserved ? "" : _identifier.reservedWords[options.ecmaVersion] + (options.sourceType == "module" ? " await" : "");
    this.reservedWords = keywordRegexp(reserved);
    var reservedStrict = (reserved ? reserved + " " : "") + _identifier.reservedWords.strict;
    this.reservedWordsStrict = keywordRegexp(reservedStrict);
    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + _identifier.reservedWords.strictBind);
    this.input = String(input); // Used to signal to callers of `readWord1` whether the word
    // contained any escape sequences. This is needed because words with
    // escape sequences must not be interpreted as keywords.

    this.containsEsc = false; // Load plugins

    this.loadPlugins(options.plugins); // Set up token state
    // The current position of the tokenizer in the input.

    if (startPos) {
      this.pos = startPos;
      this.lineStart = Math.max(0, this.input.lastIndexOf("\n", startPos));
      this.curLine = this.input.slice(0, this.lineStart).split(_whitespace.lineBreak).length;
    } else {
      this.pos = this.lineStart = 0;
      this.curLine = 1;
    } // Properties of the current token:
    // Its type


    this.type = _tokentype.types.eof; // For tokens that include more information than their type, the value

    this.value = null; // Its start and end offset

    this.start = this.end = this.pos; // And, if locations are used, the {line, column} object
    // corresponding to those offsets

    this.startLoc = this.endLoc = this.curPosition(); // Position information for the previous token

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos; // The context stack is used to superficially track syntactic
    // context to predict whether a regular expression is allowed in a
    // given position.

    this.context = this.initialContext();
    this.exprAllowed = true; // Figure out if it's a module code.

    this.strict = this.inModule = options.sourceType === "module"; // Used to signify the start of a potential arrow function

    this.potentialArrowAt = -1; // Flags to track whether we are in a function, a generator.

    this.inFunction = this.inGenerator = false; // Labels in scope.

    this.labels = []; // If enabled, skip leading hashbang line.

    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!') this.skipLineComment(2);
  } // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them


  _createClass(Parser, [{
    key: "isKeyword",
    value: function isKeyword(word) {
      return this.keywords.test(word);
    }
  }, {
    key: "isReservedWord",
    value: function isReservedWord(word) {
      return this.reservedWords.test(word);
    }
  }, {
    key: "extend",
    value: function extend(name, f) {
      this[name] = f(this[name]);
    }
  }, {
    key: "loadPlugins",
    value: function loadPlugins(pluginConfigs) {
      for (var name in pluginConfigs) {
        var plugin = plugins[name];
        if (!plugin) throw new Error("Plugin '" + name + "' not found");
        plugin(this, pluginConfigs[name]);
      }
    }
  }, {
    key: "parse",
    value: function parse() {
      var node = this.options.program || this.startNode();
      this.nextToken();
      return this.parseTopLevel(node);
    }
  }]);

  return Parser;
}();

exports.Parser = Parser;