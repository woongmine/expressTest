"use strict";

var _state = require("./state");

var _parseutil = require("./parseutil");

var _index = require("../index");

var lp = _state.LooseParser.prototype;

lp.parseTopLevel = function () {
  var node = this.startNodeAt(this.options.locations ? [0, (0, _index.getLineInfo)(this.input, 0)] : 0);
  node.body = [];

  while (this.tok.type !== _index.tokTypes.eof) {
    node.body.push(this.parseStatement());
  }

  this.last = this.tok;

  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }

  return this.finishNode(node, "Program");
};

lp.parseStatement = function () {
  var starttype = this.tok.type,
      node = this.startNode(),
      kind;

  if (this.toks.isLet()) {
    starttype = _index.tokTypes._var;
    kind = "let";
  }

  switch (starttype) {
    case _index.tokTypes._break:
    case _index.tokTypes._continue:
      this.next();
      var isBreak = starttype === _index.tokTypes._break;

      if (this.semicolon() || this.canInsertSemicolon()) {
        node.label = null;
      } else {
        node.label = this.tok.type === _index.tokTypes.name ? this.parseIdent() : null;
        this.semicolon();
      }

      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");

    case _index.tokTypes._debugger:
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");

    case _index.tokTypes._do:
      this.next();
      node.body = this.parseStatement();
      node.test = this.eat(_index.tokTypes._while) ? this.parseParenExpression() : this.dummyIdent();
      this.semicolon();
      return this.finishNode(node, "DoWhileStatement");

    case _index.tokTypes._for:
      this.next();
      this.pushCx();
      this.expect(_index.tokTypes.parenL);
      if (this.tok.type === _index.tokTypes.semi) return this.parseFor(node, null);
      var isLet = this.toks.isLet();

      if (isLet || this.tok.type === _index.tokTypes._var || this.tok.type === _index.tokTypes._const) {
        var _init = this.parseVar(true, isLet ? "let" : this.tok.value);

        if (_init.declarations.length === 1 && (this.tok.type === _index.tokTypes._in || this.isContextual("of"))) {
          return this.parseForIn(node, _init);
        }

        return this.parseFor(node, _init);
      }

      var init = this.parseExpression(true);
      if (this.tok.type === _index.tokTypes._in || this.isContextual("of")) return this.parseForIn(node, this.toAssignable(init));
      return this.parseFor(node, init);

    case _index.tokTypes._function:
      this.next();
      return this.parseFunction(node, true);

    case _index.tokTypes._if:
      this.next();
      node.test = this.parseParenExpression();
      node.consequent = this.parseStatement();
      node.alternate = this.eat(_index.tokTypes._else) ? this.parseStatement() : null;
      return this.finishNode(node, "IfStatement");

    case _index.tokTypes._return:
      this.next();
      if (this.eat(_index.tokTypes.semi) || this.canInsertSemicolon()) node.argument = null;else {
        node.argument = this.parseExpression();
        this.semicolon();
      }
      return this.finishNode(node, "ReturnStatement");

    case _index.tokTypes._switch:
      var blockIndent = this.curIndent,
          line = this.curLineStart;
      this.next();
      node.discriminant = this.parseParenExpression();
      node.cases = [];
      this.pushCx();
      this.expect(_index.tokTypes.braceL);
      var cur;

      while (!this.closes(_index.tokTypes.braceR, blockIndent, line, true)) {
        if (this.tok.type === _index.tokTypes._case || this.tok.type === _index.tokTypes._default) {
          var isCase = this.tok.type === _index.tokTypes._case;
          if (cur) this.finishNode(cur, "SwitchCase");
          node.cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();
          if (isCase) cur.test = this.parseExpression();else cur.test = null;
          this.expect(_index.tokTypes.colon);
        } else {
          if (!cur) {
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            cur.test = null;
          }

          cur.consequent.push(this.parseStatement());
        }
      }

      if (cur) this.finishNode(cur, "SwitchCase");
      this.popCx();
      this.eat(_index.tokTypes.braceR);
      return this.finishNode(node, "SwitchStatement");

    case _index.tokTypes._throw:
      this.next();
      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");

    case _index.tokTypes._try:
      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.tok.type === _index.tokTypes._catch) {
        var clause = this.startNode();
        this.next();
        this.expect(_index.tokTypes.parenL);
        clause.param = this.toAssignable(this.parseExprAtom(), true);
        this.expect(_index.tokTypes.parenR);
        clause.body = this.parseBlock();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(_index.tokTypes._finally) ? this.parseBlock() : null;
      if (!node.handler && !node.finalizer) return node.block;
      return this.finishNode(node, "TryStatement");

    case _index.tokTypes._var:
    case _index.tokTypes._const:
      return this.parseVar(false, kind || this.tok.value);

    case _index.tokTypes._while:
      this.next();
      node.test = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WhileStatement");

    case _index.tokTypes._with:
      this.next();
      node.object = this.parseParenExpression();
      node.body = this.parseStatement();
      return this.finishNode(node, "WithStatement");

    case _index.tokTypes.braceL:
      return this.parseBlock();

    case _index.tokTypes.semi:
      this.next();
      return this.finishNode(node, "EmptyStatement");

    case _index.tokTypes._class:
      return this.parseClass(true);

    case _index.tokTypes._import:
      return this.parseImport();

    case _index.tokTypes._export:
      return this.parseExport();

    default:
      if (this.toks.isAsyncFunction()) {
        this.next();
        this.next();
        return this.parseFunction(node, true, true);
      }

      var expr = this.parseExpression();

      if ((0, _parseutil.isDummy)(expr)) {
        this.next();
        if (this.tok.type === _index.tokTypes.eof) return this.finishNode(node, "EmptyStatement");
        return this.parseStatement();
      } else if (starttype === _index.tokTypes.name && expr.type === "Identifier" && this.eat(_index.tokTypes.colon)) {
        node.body = this.parseStatement();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      } else {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }

  }
};

lp.parseBlock = function () {
  var node = this.startNode();
  this.pushCx();
  this.expect(_index.tokTypes.braceL);
  var blockIndent = this.curIndent,
      line = this.curLineStart;
  node.body = [];

  while (!this.closes(_index.tokTypes.braceR, blockIndent, line, true)) {
    node.body.push(this.parseStatement());
  }

  this.popCx();
  this.eat(_index.tokTypes.braceR);
  return this.finishNode(node, "BlockStatement");
};

lp.parseFor = function (node, init) {
  node.init = init;
  node.test = node.update = null;
  if (this.eat(_index.tokTypes.semi) && this.tok.type !== _index.tokTypes.semi) node.test = this.parseExpression();
  if (this.eat(_index.tokTypes.semi) && this.tok.type !== _index.tokTypes.parenR) node.update = this.parseExpression();
  this.popCx();
  this.expect(_index.tokTypes.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, "ForStatement");
};

lp.parseForIn = function (node, init) {
  var type = this.tok.type === _index.tokTypes._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.popCx();
  this.expect(_index.tokTypes.parenR);
  node.body = this.parseStatement();
  return this.finishNode(node, type);
};

lp.parseVar = function (noIn, kind) {
  var node = this.startNode();
  node.kind = kind;
  this.next();
  node.declarations = [];

  do {
    var decl = this.startNode();
    decl.id = this.options.ecmaVersion >= 6 ? this.toAssignable(this.parseExprAtom(), true) : this.parseIdent();
    decl.init = this.eat(_index.tokTypes.eq) ? this.parseMaybeAssign(noIn) : null;
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
  } while (this.eat(_index.tokTypes.comma));

  if (!node.declarations.length) {
    var _decl = this.startNode();

    _decl.id = this.dummyIdent();
    node.declarations.push(this.finishNode(_decl, "VariableDeclarator"));
  }

  if (!noIn) this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

lp.parseClass = function (isStatement) {
  var node = this.startNode();
  this.next();
  if (isStatement == null) isStatement = this.tok.type === _index.tokTypes.name;
  if (this.tok.type === _index.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();else node.id = null;
  node.superClass = this.eat(_index.tokTypes._extends) ? this.parseExpression() : null;
  node.body = this.startNode();
  node.body.body = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(_index.tokTypes.braceL);

  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;
    line = this.curLineStart;
  }

  while (!this.closes(_index.tokTypes.braceR, indent, line)) {
    if (this.semicolon()) continue;
    var method = this.startNode(),
        isGenerator = void 0,
        isAsync = void 0;

    if (this.options.ecmaVersion >= 6) {
      method["static"] = false;
      isGenerator = this.eat(_index.tokTypes.star);
    }

    this.parsePropertyName(method);

    if ((0, _parseutil.isDummy)(method.key)) {
      if ((0, _parseutil.isDummy)(this.parseMaybeAssign())) this.next();
      this.eat(_index.tokTypes.comma);
      continue;
    }

    if (method.key.type === "Identifier" && !method.computed && method.key.name === "static" && this.tok.type != _index.tokTypes.parenL && this.tok.type != _index.tokTypes.braceL) {
      method["static"] = true;
      isGenerator = this.eat(_index.tokTypes.star);
      this.parsePropertyName(method);
    } else {
      method["static"] = false;
    }

    if (!method.computed && method.key.type === "Identifier" && method.key.name === "async" && this.tok.type !== _index.tokTypes.parenL && !this.canInsertSemicolon()) {
      this.parsePropertyName(method);
      isAsync = true;
    } else {
      isAsync = false;
    }

    if (this.options.ecmaVersion >= 5 && method.key.type === "Identifier" && !method.computed && (method.key.name === "get" || method.key.name === "set") && this.tok.type !== _index.tokTypes.parenL && this.tok.type !== _index.tokTypes.braceL) {
      method.kind = method.key.name;
      this.parsePropertyName(method);
      method.value = this.parseMethod(false);
    } else {
      if (!method.computed && !method["static"] && !isGenerator && !isAsync && (method.key.type === "Identifier" && method.key.name === "constructor" || method.key.type === "Literal" && method.key.value === "constructor")) {
        method.kind = "constructor";
      } else {
        method.kind = "method";
      }

      method.value = this.parseMethod(isGenerator, isAsync);
    }

    node.body.body.push(this.finishNode(method, "MethodDefinition"));
  }

  this.popCx();

  if (!this.eat(_index.tokTypes.braceR)) {
    // If there is no closing brace, make the node span to the start
    // of the next token (this is useful for Tern)
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }

  this.semicolon();
  this.finishNode(node.body, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

lp.parseFunction = function (node, isStatement, isAsync) {
  var oldInAsync = this.inAsync;
  this.initFunction(node);

  if (this.options.ecmaVersion >= 6) {
    node.generator = this.eat(_index.tokTypes.star);
  }

  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }

  if (isStatement == null) isStatement = this.tok.type === _index.tokTypes.name;
  if (this.tok.type === _index.tokTypes.name) node.id = this.parseIdent();else if (isStatement) node.id = this.dummyIdent();
  this.inAsync = node.async;
  node.params = this.parseFunctionParams();
  node.body = this.parseBlock();
  this.inAsync = oldInAsync;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

lp.parseExport = function () {
  var node = this.startNode();
  this.next();

  if (this.eat(_index.tokTypes.star)) {
    node.source = this.eatContextual("from") ? this.parseExprAtom() : this.dummyString();
    return this.finishNode(node, "ExportAllDeclaration");
  }

  if (this.eat(_index.tokTypes._default)) {
    // export default (function foo() {}) // This is FunctionExpression.
    var isAsync;

    if (this.tok.type === _index.tokTypes._function || (isAsync = this.toks.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) this.next();
      node.declaration = this.parseFunction(fNode, null, isAsync);
    } else if (this.tok.type === _index.tokTypes._class) {
      node.declaration = this.parseClass(null);
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }

    return this.finishNode(node, "ExportDefaultDeclaration");
  }

  if (this.tok.type.keyword || this.toks.isLet() || this.toks.isAsyncFunction()) {
    node.declaration = this.parseStatement();
    node.specifiers = [];
    node.source = null;
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifierList();
    node.source = this.eatContextual("from") ? this.parseExprAtom() : null;
    this.semicolon();
  }

  return this.finishNode(node, "ExportNamedDeclaration");
};

lp.parseImport = function () {
  var node = this.startNode();
  this.next();

  if (this.tok.type === _index.tokTypes.string) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
    node.kind = '';
  } else {
    var elt;

    if (this.tok.type === _index.tokTypes.name && this.tok.value !== "from") {
      elt = this.startNode();
      elt.local = this.parseIdent();
      this.finishNode(elt, "ImportDefaultSpecifier");
      this.eat(_index.tokTypes.comma);
    }

    node.specifiers = this.parseImportSpecifierList();
    node.source = this.eatContextual("from") && this.tok.type == _index.tokTypes.string ? this.parseExprAtom() : this.dummyString();
    if (elt) node.specifiers.unshift(elt);
  }

  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

lp.parseImportSpecifierList = function () {
  var elts = [];

  if (this.tok.type === _index.tokTypes.star) {
    var elt = this.startNode();
    this.next();
    elt.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent();
    elts.push(this.finishNode(elt, "ImportNamespaceSpecifier"));
  } else {
    var indent = this.curIndent,
        line = this.curLineStart,
        continuedLine = this.nextLineStart;
    this.pushCx();
    this.eat(_index.tokTypes.braceL);
    if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;

    while (!this.closes(_index.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
      var _elt = this.startNode();

      if (this.eat(_index.tokTypes.star)) {
        _elt.local = this.eatContextual("as") ? this.parseIdent() : this.dummyIdent();
        this.finishNode(_elt, "ImportNamespaceSpecifier");
      } else {
        if (this.isContextual("from")) break;
        _elt.imported = this.parseIdent();
        if ((0, _parseutil.isDummy)(_elt.imported)) break;
        _elt.local = this.eatContextual("as") ? this.parseIdent() : _elt.imported;
        this.finishNode(_elt, "ImportSpecifier");
      }

      elts.push(_elt);
      this.eat(_index.tokTypes.comma);
    }

    this.eat(_index.tokTypes.braceR);
    this.popCx();
  }

  return elts;
};

lp.parseExportSpecifierList = function () {
  var elts = [];
  var indent = this.curIndent,
      line = this.curLineStart,
      continuedLine = this.nextLineStart;
  this.pushCx();
  this.eat(_index.tokTypes.braceL);
  if (this.curLineStart > continuedLine) continuedLine = this.curLineStart;

  while (!this.closes(_index.tokTypes.braceR, indent + (this.curLineStart <= continuedLine ? 1 : 0), line)) {
    if (this.isContextual("from")) break;
    var elt = this.startNode();
    elt.local = this.parseIdent();
    if ((0, _parseutil.isDummy)(elt.local)) break;
    elt.exported = this.eatContextual("as") ? this.parseIdent() : elt.local;
    this.finishNode(elt, "ExportSpecifier");
    elts.push(elt);
    this.eat(_index.tokTypes.comma);
  }

  this.eat(_index.tokTypes.braceR);
  this.popCx();
  return elts;
};