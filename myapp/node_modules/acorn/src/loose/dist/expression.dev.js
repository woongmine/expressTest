"use strict";

var _state = require("./state");

var _parseutil = require("./parseutil");

var _index = require("../index");

var lp = _state.LooseParser.prototype;

lp.checkLVal = function (expr) {
  if (!expr) return expr;

  switch (expr.type) {
    case "Identifier":
    case "MemberExpression":
      return expr;

    case "ParenthesizedExpression":
      expr.expression = this.checkLVal(expr.expression);
      return expr;

    default:
      return this.dummyIdent();
  }
};

lp.parseExpression = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseMaybeAssign(noIn);

  if (this.tok.type === _index.tokTypes.comma) {
    var node = this.startNodeAt(start);
    node.expressions = [expr];

    while (this.eat(_index.tokTypes.comma)) {
      node.expressions.push(this.parseMaybeAssign(noIn));
    }

    return this.finishNode(node, "SequenceExpression");
  }

  return expr;
};

lp.parseParenExpression = function () {
  this.pushCx();
  this.expect(_index.tokTypes.parenL);
  var val = this.parseExpression();
  this.popCx();
  this.expect(_index.tokTypes.parenR);
  return val;
};

lp.parseMaybeAssign = function (noIn) {
  if (this.toks.isContextual("yield")) {
    var node = this.startNode();
    this.next();

    if (this.semicolon() || this.canInsertSemicolon() || this.tok.type != _index.tokTypes.star && !this.tok.type.startsExpr) {
      node.delegate = false;
      node.argument = null;
    } else {
      node.delegate = this.eat(_index.tokTypes.star);
      node.argument = this.parseMaybeAssign();
    }

    return this.finishNode(node, "YieldExpression");
  }

  var start = this.storeCurrentPos();
  var left = this.parseMaybeConditional(noIn);

  if (this.tok.type.isAssign) {
    var _node = this.startNodeAt(start);

    _node.operator = this.tok.value;
    _node.left = this.tok.type === _index.tokTypes.eq ? this.toAssignable(left) : this.checkLVal(left);
    this.next();
    _node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(_node, "AssignmentExpression");
  }

  return left;
};

lp.parseMaybeConditional = function (noIn) {
  var start = this.storeCurrentPos();
  var expr = this.parseExprOps(noIn);

  if (this.eat(_index.tokTypes.question)) {
    var node = this.startNodeAt(start);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    node.alternate = this.expect(_index.tokTypes.colon) ? this.parseMaybeAssign(noIn) : this.dummyIdent();
    return this.finishNode(node, "ConditionalExpression");
  }

  return expr;
};

lp.parseExprOps = function (noIn) {
  var start = this.storeCurrentPos();
  var indent = this.curIndent,
      line = this.curLineStart;
  return this.parseExprOp(this.parseMaybeUnary(false), start, -1, noIn, indent, line);
};

lp.parseExprOp = function (left, start, minPrec, noIn, indent, line) {
  if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) return left;
  var prec = this.tok.type.binop;

  if (prec != null && (!noIn || this.tok.type !== _index.tokTypes._in)) {
    if (prec > minPrec) {
      var node = this.startNodeAt(start);
      node.left = left;
      node.operator = this.tok.value;
      this.next();

      if (this.curLineStart != line && this.curIndent < indent && this.tokenStartsLine()) {
        node.right = this.dummyIdent();
      } else {
        var rightStart = this.storeCurrentPos();
        node.right = this.parseExprOp(this.parseMaybeUnary(false), rightStart, prec, noIn, indent, line);
      }

      this.finishNode(node, /&&|\|\|/.test(node.operator) ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, start, minPrec, noIn, indent, line);
    }
  }

  return left;
};

lp.parseMaybeUnary = function (sawUnary) {
  var start = this.storeCurrentPos(),
      expr;

  if (this.options.ecmaVersion >= 8 && this.inAsync && this.toks.isContextual("await")) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.tok.type.prefix) {
    var node = this.startNode(),
        update = this.tok.type === _index.tokTypes.incDec;
    if (!update) sawUnary = true;
    node.operator = this.tok.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(true);
    if (update) node.argument = this.checkLVal(node.argument);
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (this.tok.type === _index.tokTypes.ellipsis) {
    var _node2 = this.startNode();

    this.next();
    _node2.argument = this.parseMaybeUnary(sawUnary);
    expr = this.finishNode(_node2, "SpreadElement");
  } else {
    expr = this.parseExprSubscripts();

    while (this.tok.type.postfix && !this.canInsertSemicolon()) {
      var _node3 = this.startNodeAt(start);

      _node3.operator = this.tok.value;
      _node3.prefix = false;
      _node3.argument = this.checkLVal(expr);
      this.next();
      expr = this.finishNode(_node3, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(_index.tokTypes.starstar)) {
    var _node4 = this.startNodeAt(start);

    _node4.operator = "**";
    _node4.left = expr;
    _node4.right = this.parseMaybeUnary(false);
    return this.finishNode(_node4, "BinaryExpression");
  }

  return expr;
};

lp.parseExprSubscripts = function () {
  var start = this.storeCurrentPos();
  return this.parseSubscripts(this.parseExprAtom(), start, false, this.curIndent, this.curLineStart);
};

lp.parseSubscripts = function (base, start, noCalls, startIndent, line) {
  for (;;) {
    if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) {
      if (this.tok.type == _index.tokTypes.dot && this.curIndent == startIndent) --startIndent;else return base;
    }

    var maybeAsyncArrow = base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();

    if (this.eat(_index.tokTypes.dot)) {
      var node = this.startNodeAt(start);
      node.object = base;
      if (this.curLineStart != line && this.curIndent <= startIndent && this.tokenStartsLine()) node.property = this.dummyIdent();else node.property = this.parsePropertyAccessor() || this.dummyIdent();
      node.computed = false;
      base = this.finishNode(node, "MemberExpression");
    } else if (this.tok.type == _index.tokTypes.bracketL) {
      this.pushCx();
      this.next();

      var _node5 = this.startNodeAt(start);

      _node5.object = base;
      _node5.property = this.parseExpression();
      _node5.computed = true;
      this.popCx();
      this.expect(_index.tokTypes.bracketR);
      base = this.finishNode(_node5, "MemberExpression");
    } else if (!noCalls && this.tok.type == _index.tokTypes.parenL) {
      var exprList = this.parseExprList(_index.tokTypes.parenR);
      if (maybeAsyncArrow && this.eat(_index.tokTypes.arrow)) return this.parseArrowExpression(this.startNodeAt(start), exprList, true);

      var _node6 = this.startNodeAt(start);

      _node6.callee = base;
      _node6.arguments = exprList;
      base = this.finishNode(_node6, "CallExpression");
    } else if (this.tok.type == _index.tokTypes.backQuote) {
      var _node7 = this.startNodeAt(start);

      _node7.tag = base;
      _node7.quasi = this.parseTemplate();
      base = this.finishNode(_node7, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

lp.parseExprAtom = function () {
  var node;

  switch (this.tok.type) {
    case _index.tokTypes._this:
    case _index.tokTypes._super:
      var type = this.tok.type === _index.tokTypes._this ? "ThisExpression" : "Super";
      node = this.startNode();
      this.next();
      return this.finishNode(node, type);

    case _index.tokTypes.name:
      var start = this.storeCurrentPos();
      var id = this.parseIdent();
      var isAsync = false;

      if (id.name === "async" && !this.canInsertSemicolon()) {
        if (this.eat(_index.tokTypes._function)) return this.parseFunction(this.startNodeAt(start), false, true);

        if (this.tok.type === _index.tokTypes.name) {
          id = this.parseIdent();
          isAsync = true;
        }
      }

      return this.eat(_index.tokTypes.arrow) ? this.parseArrowExpression(this.startNodeAt(start), [id], isAsync) : id;

    case _index.tokTypes.regexp:
      node = this.startNode();
      var val = this.tok.value;
      node.regex = {
        pattern: val.pattern,
        flags: val.flags
      };
      node.value = val.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case _index.tokTypes.num:
    case _index.tokTypes.string:
      node = this.startNode();
      node.value = this.tok.value;
      node.raw = this.input.slice(this.tok.start, this.tok.end);
      this.next();
      return this.finishNode(node, "Literal");

    case _index.tokTypes._null:
    case _index.tokTypes._true:
    case _index.tokTypes._false:
      node = this.startNode();
      node.value = this.tok.type === _index.tokTypes._null ? null : this.tok.type === _index.tokTypes._true;
      node.raw = this.tok.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");

    case _index.tokTypes.parenL:
      var parenStart = this.storeCurrentPos();
      this.next();
      var inner = this.parseExpression();
      this.expect(_index.tokTypes.parenR);

      if (this.eat(_index.tokTypes.arrow)) {
        // (a,)=>a // SequenceExpression makes dummy in the last hole. Drop the dummy.
        var params = inner.expressions || [inner];
        if (params.length && (0, _parseutil.isDummy)(params[params.length - 1])) params.pop();
        return this.parseArrowExpression(this.startNodeAt(parenStart), params);
      }

      if (this.options.preserveParens) {
        var par = this.startNodeAt(parenStart);
        par.expression = inner;
        inner = this.finishNode(par, "ParenthesizedExpression");
      }

      return inner;

    case _index.tokTypes.bracketL:
      node = this.startNode();
      node.elements = this.parseExprList(_index.tokTypes.bracketR, true);
      return this.finishNode(node, "ArrayExpression");

    case _index.tokTypes.braceL:
      return this.parseObj();

    case _index.tokTypes._class:
      return this.parseClass(false);

    case _index.tokTypes._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, false);

    case _index.tokTypes._new:
      return this.parseNew();

    case _index.tokTypes.backQuote:
      return this.parseTemplate();

    default:
      return this.dummyIdent();
  }
};

lp.parseNew = function () {
  var node = this.startNode(),
      startIndent = this.curIndent,
      line = this.curLineStart;
  var meta = this.parseIdent(true);

  if (this.options.ecmaVersion >= 6 && this.eat(_index.tokTypes.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    return this.finishNode(node, "MetaProperty");
  }

  var start = this.storeCurrentPos();
  node.callee = this.parseSubscripts(this.parseExprAtom(), start, true, startIndent, line);

  if (this.tok.type == _index.tokTypes.parenL) {
    node.arguments = this.parseExprList(_index.tokTypes.parenR);
  } else {
    node.arguments = [];
  }

  return this.finishNode(node, "NewExpression");
};

lp.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.tok.start, this.tok.end).replace(/\r\n?/g, '\n'),
    cooked: this.tok.value
  };
  this.next();
  elem.tail = this.tok.type === _index.tokTypes.backQuote;
  return this.finishNode(elem, "TemplateElement");
};

lp.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];

  while (!curElt.tail) {
    this.next();
    node.expressions.push(this.parseExpression());

    if (this.expect(_index.tokTypes.braceR)) {
      curElt = this.parseTemplateElement();
    } else {
      curElt = this.startNode();
      curElt.value = {
        cooked: '',
        raw: ''
      };
      curElt.tail = true;
      this.finishNode(curElt, "TemplateElement");
    }

    node.quasis.push(curElt);
  }

  this.expect(_index.tokTypes.backQuote);
  return this.finishNode(node, "TemplateLiteral");
};

lp.parseObj = function () {
  var node = this.startNode();
  node.properties = [];
  this.pushCx();
  var indent = this.curIndent + 1,
      line = this.curLineStart;
  this.eat(_index.tokTypes.braceL);

  if (this.curIndent + 1 < indent) {
    indent = this.curIndent;
    line = this.curLineStart;
  }

  while (!this.closes(_index.tokTypes.braceR, indent, line)) {
    var prop = this.startNode(),
        isGenerator = void 0,
        isAsync = void 0,
        start = void 0;

    if (this.options.ecmaVersion >= 6) {
      start = this.storeCurrentPos();
      prop.method = false;
      prop.shorthand = false;
      isGenerator = this.eat(_index.tokTypes.star);
    }

    this.parsePropertyName(prop);

    if (!prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && this.tok.type !== _index.tokTypes.parenL && this.tok.type !== _index.tokTypes.colon && !this.canInsertSemicolon()) {
      this.parsePropertyName(prop);
      isAsync = true;
    } else {
      isAsync = false;
    }

    if ((0, _parseutil.isDummy)(prop.key)) {
      if ((0, _parseutil.isDummy)(this.parseMaybeAssign())) this.next();
      this.eat(_index.tokTypes.comma);
      continue;
    }

    if (this.eat(_index.tokTypes.colon)) {
      prop.kind = "init";
      prop.value = this.parseMaybeAssign();
    } else if (this.options.ecmaVersion >= 6 && (this.tok.type === _index.tokTypes.parenL || this.tok.type === _index.tokTypes.braceL)) {
      prop.kind = "init";
      prop.method = true;
      prop.value = this.parseMethod(isGenerator, isAsync);
    } else if (this.options.ecmaVersion >= 5 && prop.key.type === "Identifier" && !prop.computed && (prop.key.name === "get" || prop.key.name === "set") && this.tok.type != _index.tokTypes.comma && this.tok.type != _index.tokTypes.braceR) {
      prop.kind = prop.key.name;
      this.parsePropertyName(prop);
      prop.value = this.parseMethod(false);
    } else {
      prop.kind = "init";

      if (this.options.ecmaVersion >= 6) {
        if (this.eat(_index.tokTypes.eq)) {
          var assign = this.startNodeAt(start);
          assign.operator = "=";
          assign.left = prop.key;
          assign.right = this.parseMaybeAssign();
          prop.value = this.finishNode(assign, "AssignmentExpression");
        } else {
          prop.value = prop.key;
        }
      } else {
        prop.value = this.dummyIdent();
      }

      prop.shorthand = true;
    }

    node.properties.push(this.finishNode(prop, "Property"));
    this.eat(_index.tokTypes.comma);
  }

  this.popCx();

  if (!this.eat(_index.tokTypes.braceR)) {
    // If there is no closing brace, make the node span to the start
    // of the next token (this is useful for Tern)
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }

  return this.finishNode(node, "ObjectExpression");
};

lp.parsePropertyName = function (prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(_index.tokTypes.bracketL)) {
      prop.computed = true;
      prop.key = this.parseExpression();
      this.expect(_index.tokTypes.bracketR);
      return;
    } else {
      prop.computed = false;
    }
  }

  var key = this.tok.type === _index.tokTypes.num || this.tok.type === _index.tokTypes.string ? this.parseExprAtom() : this.parseIdent();
  prop.key = key || this.dummyIdent();
};

lp.parsePropertyAccessor = function () {
  if (this.tok.type === _index.tokTypes.name || this.tok.type.keyword) return this.parseIdent();
};

lp.parseIdent = function () {
  var name = this.tok.type === _index.tokTypes.name ? this.tok.value : this.tok.type.keyword;
  if (!name) return this.dummyIdent();
  var node = this.startNode();
  this.next();
  node.name = name;
  return this.finishNode(node, "Identifier");
};

lp.initFunction = function (node) {
  node.id = null;
  node.params = [];

  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }

  if (this.options.ecmaVersion >= 8) node.async = false;
}; // Convert existing expression atom to assignable pattern
// if possible.


lp.toAssignable = function (node, binding) {
  if (!node || node.type == "Identifier" || node.type == "MemberExpression" && !binding) {// Okay
  } else if (node.type == "ParenthesizedExpression") {
    node.expression = this.toAssignable(node.expression, binding);
  } else if (this.options.ecmaVersion < 6) {
    return this.dummyIdent();
  } else if (node.type == "ObjectExpression") {
    node.type = "ObjectPattern";
    var props = node.properties;

    for (var i = 0; i < props.length; i++) {
      props[i].value = this.toAssignable(props[i].value, binding);
    }
  } else if (node.type == "ArrayExpression") {
    node.type = "ArrayPattern";
    this.toAssignableList(node.elements, binding);
  } else if (node.type == "SpreadElement") {
    node.type = "RestElement";
    node.argument = this.toAssignable(node.argument, binding);
  } else if (node.type == "AssignmentExpression") {
    node.type = "AssignmentPattern";
    delete node.operator;
  } else {
    return this.dummyIdent();
  }

  return node;
};

lp.toAssignableList = function (exprList, binding) {
  for (var i = 0; i < exprList.length; i++) {
    exprList[i] = this.toAssignable(exprList[i], binding);
  }

  return exprList;
};

lp.parseFunctionParams = function (params) {
  params = this.parseExprList(_index.tokTypes.parenR);
  return this.toAssignableList(params, true);
};

lp.parseMethod = function (isGenerator, isAsync) {
  var node = this.startNode(),
      oldInAsync = this.inAsync;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) node.generator = !!isGenerator;
  if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
  this.inAsync = node.async;
  node.params = this.parseFunctionParams();
  node.expression = this.options.ecmaVersion >= 6 && this.tok.type !== _index.tokTypes.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  this.inAsync = oldInAsync;
  return this.finishNode(node, "FunctionExpression");
};

lp.parseArrowExpression = function (node, params, isAsync) {
  var oldInAsync = this.inAsync;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) node.async = !!isAsync;
  this.inAsync = node.async;
  node.params = this.toAssignableList(params, true);
  node.expression = this.tok.type !== _index.tokTypes.braceL;
  node.body = node.expression ? this.parseMaybeAssign() : this.parseBlock();
  this.inAsync = oldInAsync;
  return this.finishNode(node, "ArrowFunctionExpression");
};

lp.parseExprList = function (close, allowEmpty) {
  this.pushCx();
  var indent = this.curIndent,
      line = this.curLineStart,
      elts = [];
  this.next(); // Opening bracket

  while (!this.closes(close, indent + 1, line)) {
    if (this.eat(_index.tokTypes.comma)) {
      elts.push(allowEmpty ? null : this.dummyIdent());
      continue;
    }

    var elt = this.parseMaybeAssign();

    if ((0, _parseutil.isDummy)(elt)) {
      if (this.closes(close, indent, line)) break;
      this.next();
    } else {
      elts.push(elt);
    }

    this.eat(_index.tokTypes.comma);
  }

  this.popCx();

  if (!this.eat(close)) {
    // If there is no closing brace, make the node span to the start
    // of the next token (this is useful for Tern)
    this.last.end = this.tok.start;
    if (this.options.locations) this.last.loc.end = this.tok.loc.start;
  }

  return elts;
};

lp.parseAwait = function () {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary();
  return this.finishNode(node, "AwaitExpression");
};