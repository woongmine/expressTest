"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LooseParser = exports.pluginsLoose = void 0;

var _index = require("../index");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var pluginsLoose = {};
exports.pluginsLoose = pluginsLoose;

var LooseParser =
/*#__PURE__*/
function () {
  function LooseParser(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, LooseParser);

    this.toks = (0, _index.tokenizer)(input, options);
    this.options = this.toks.options;
    this.input = this.toks.input;
    this.tok = this.last = {
      type: _index.tokTypes.eof,
      start: 0,
      end: 0
    };

    if (this.options.locations) {
      var here = this.toks.curPosition();
      this.tok.loc = new _index.SourceLocation(this.toks, here, here);
    }

    this.ahead = []; // Tokens ahead

    this.context = []; // Indentation contexted

    this.curIndent = 0;
    this.curLineStart = 0;
    this.nextLineStart = this.lineEnd(this.curLineStart) + 1;
    this.inAsync = false; // Load plugins

    this.options.pluginsLoose = options.pluginsLoose || {};
    this.loadPlugins(this.options.pluginsLoose);
  }

  _createClass(LooseParser, [{
    key: "startNode",
    value: function startNode() {
      return new _index.Node(this.toks, this.tok.start, this.options.locations ? this.tok.loc.start : null);
    }
  }, {
    key: "storeCurrentPos",
    value: function storeCurrentPos() {
      return this.options.locations ? [this.tok.start, this.tok.loc.start] : this.tok.start;
    }
  }, {
    key: "startNodeAt",
    value: function startNodeAt(pos) {
      if (this.options.locations) {
        return new _index.Node(this.toks, pos[0], pos[1]);
      } else {
        return new _index.Node(this.toks, pos);
      }
    }
  }, {
    key: "finishNode",
    value: function finishNode(node, type) {
      node.type = type;
      node.end = this.last.end;
      if (this.options.locations) node.loc.end = this.last.loc.end;
      if (this.options.ranges) node.range[1] = this.last.end;
      return node;
    }
  }, {
    key: "dummyNode",
    value: function dummyNode(type) {
      var dummy = this.startNode();
      dummy.type = type;
      dummy.end = dummy.start;
      if (this.options.locations) dummy.loc.end = dummy.loc.start;
      if (this.options.ranges) dummy.range[1] = dummy.start;
      this.last = {
        type: _index.tokTypes.name,
        start: dummy.start,
        end: dummy.start,
        loc: dummy.loc
      };
      return dummy;
    }
  }, {
    key: "dummyIdent",
    value: function dummyIdent() {
      var dummy = this.dummyNode("Identifier");
      dummy.name = "✖";
      return dummy;
    }
  }, {
    key: "dummyString",
    value: function dummyString() {
      var dummy = this.dummyNode("Literal");
      dummy.value = dummy.raw = "✖";
      return dummy;
    }
  }, {
    key: "eat",
    value: function eat(type) {
      if (this.tok.type === type) {
        this.next();
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "isContextual",
    value: function isContextual(name) {
      return this.tok.type === _index.tokTypes.name && this.tok.value === name;
    }
  }, {
    key: "eatContextual",
    value: function eatContextual(name) {
      return this.tok.value === name && this.eat(_index.tokTypes.name);
    }
  }, {
    key: "canInsertSemicolon",
    value: function canInsertSemicolon() {
      return this.tok.type === _index.tokTypes.eof || this.tok.type === _index.tokTypes.braceR || _index.lineBreak.test(this.input.slice(this.last.end, this.tok.start));
    }
  }, {
    key: "semicolon",
    value: function semicolon() {
      return this.eat(_index.tokTypes.semi);
    }
  }, {
    key: "expect",
    value: function expect(type) {
      if (this.eat(type)) return true;

      for (var i = 1; i <= 2; i++) {
        if (this.lookAhead(i).type == type) {
          for (var j = 0; j < i; j++) {
            this.next();
          }

          return true;
        }
      }
    }
  }, {
    key: "pushCx",
    value: function pushCx() {
      this.context.push(this.curIndent);
    }
  }, {
    key: "popCx",
    value: function popCx() {
      this.curIndent = this.context.pop();
    }
  }, {
    key: "lineEnd",
    value: function lineEnd(pos) {
      while (pos < this.input.length && !(0, _index.isNewLine)(this.input.charCodeAt(pos))) {
        ++pos;
      }

      return pos;
    }
  }, {
    key: "indentationAfter",
    value: function indentationAfter(pos) {
      for (var count = 0;; ++pos) {
        var ch = this.input.charCodeAt(pos);
        if (ch === 32) ++count;else if (ch === 9) count += this.options.tabSize;else return count;
      }
    }
  }, {
    key: "closes",
    value: function closes(closeTok, indent, line, blockHeuristic) {
      if (this.tok.type === closeTok || this.tok.type === _index.tokTypes.eof) return true;
      return line != this.curLineStart && this.curIndent < indent && this.tokenStartsLine() && (!blockHeuristic || this.nextLineStart >= this.input.length || this.indentationAfter(this.nextLineStart) < indent);
    }
  }, {
    key: "tokenStartsLine",
    value: function tokenStartsLine() {
      for (var p = this.tok.start - 1; p >= this.curLineStart; --p) {
        var ch = this.input.charCodeAt(p);
        if (ch !== 9 && ch !== 32) return false;
      }

      return true;
    }
  }, {
    key: "extend",
    value: function extend(name, f) {
      this[name] = f(this[name]);
    }
  }, {
    key: "loadPlugins",
    value: function loadPlugins(pluginConfigs) {
      for (var name in pluginConfigs) {
        var plugin = pluginsLoose[name];
        if (!plugin) throw new Error("Plugin '" + name + "' not found");
        plugin(this, pluginConfigs[name]);
      }
    }
  }]);

  return LooseParser;
}();

exports.LooseParser = LooseParser;